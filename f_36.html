

<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Display a satellite map on a webpage</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.js"></script>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/wnumb/1.2.0/wNumb.min.js"
        integrity="sha512-igVQ7hyQVijOUlfg3OmcTZLwYJIBXU63xL9RC12xBHNpmGJAktDnzl9Iw0J4yrSaQtDxTTVlwhY730vphoVqJQ=="
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.6.3/nouislider.min.js"
        integrity="sha512-EnXkkBUGl2gBm/EIZEgwWpQNavsnBbeMtjklwAa7jLj60mJk932aqzXFmdPKCG6ge/i8iOCK0Uwl1Qp+S0zowg=="
        crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.6.3/nouislider.css"
        integrity="sha512-XXtRBFtk/QfR8GEWwQPYjrQBHQwjidXg0wo8HJi9YOaFycWqd2uWkjJoAyx8Mb/+H8uhvmf70EAIxDnQxrwrvw=="
        crossorigin="anonymous" />

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, Helvetica, sans-serif;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .mapboxgl-ctrl-zoom-out {
            display: none !important;
        }

        .mapboxgl-ctrl-zoom-in {
            display: none !important;
        }


        #amenities {}

        .am {
            width: 150px;
            height: 150px;
            cursor: pointer;
            margin-right: 30px;
        }

        #info {
            position: absolute;
            top: 100px;
            left: 20px;
            z-index: 10000;
            display: none;
            background-color: aliceblue;
            padding: 10px;
        }

        #mainSearchPanel {
            position: fixed;
            background-color: #323232;
            bottom: 0px;
            left: 0px;
            z-index: 10000;
            background-color: #323232;
            width: 100%;
            height: 200px;
            box-sizing: border-box;
        }

        #searchPanelTop {
            position: fixed;
            bottom: 0px;
            left: 0px;
            z-index: 100;
            width: 100%;
            height: 200px;
            box-sizing: border-box;
            transition: 0.3s;
        }

        #searchPanel {
            position: fixed;
            bottom: 0px;
            left: 0px;
            z-index: 100;
            width: 100%;
            height: 0px;
            box-sizing: border-box;
            transition: 0.3s;
        }

        .noUi-origin {
            will-change: transform;
            position: absolute;
            z-index: 1;
            top: -13px;
            right: 0;
        }

        .noUi-target {
            height: 22px;
            background: #FAFAFA;
            border-radius: 104px;
            border: 1px solid #D3D3D3;
            box-shadow: inset 0 1px 1px #F0F0F0, 0 3px 6px -5px #BBB;
        }

        .noUi-horizontal .noUi-handle {
            width: 58px;
            height: 58px;
            background: #FC360C;
            border-radius: 60px;
            border: none;
            box-shadow: none;
            cursor: pointer;
            outline: none;
            border: 5px solid white;
        }

        .noUi-horizontal .noUi-handle:before,
        .noUi-horizontal .noUi-handle:after {
            content: '';
            background: transparent;
        }

        .noUi-connect {
            background: #FC360C;
            height: 22px;
        }

        .noUi-tooltip {
            border: 0px !important;
            color: #FC360C;
            font-size: 24px;
            font-weight: bold;
            background: none;
        }

        .button-container {
            display: table-cell;
            vertical-align: middle;
        }


        .button {
            background-color: white;
            border: 1px solid black;
            color: black;
            text-align: center;
            text-decoration: none;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-transform: uppercase;
            font-size: 0.55em;
            user-select: none;
        }

        .button>.big {
            font-size: 1.75em;
        }

        .selected {
            background-color: black;
            color: red;
        }

        #sliderdiv {
            align-self: center;
            justify-self: center;
            width: 510px;
        }

        #roundtab {
            /* background-color: white; */
            border-top-right-radius: 150px;
            border-bottom-right-radius: 150px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            width: 800px;
            height: 80px;
            margin-top: 10px;
            padding: 5px;
            padding-left: 50px;
            box-sizing: border-box;
        }

        #filtersDiv {
            position: absolute;
        }

        .button-container:nth-child(4) {
            padding-left: 20px;
        }

        .search-icon {
            width: 100px;
            height: 100px;
        }

        .small-icon {
            width: 40px;
            height: 40px;
        }

        .search-bar {
            background-image: url('img/search-bar-right.png');
            background-repeat: no-repeat;
            /* background-attachment: fixed; */
            /* background-position: center right -700px; */
            background-position: center right;
            background-size: 1111px 200px;
            padding: 0px;
            margin: 0px;
            border: 0px solid red;
            height: 100px;
        }

        .action {
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <div id="info"></div>

    <div id="mainSearchPanel" class="search-bar">
        <div style="position:absolute;top:90px;right:875px;">
            ZOOM
        </div>
        <div id="searchPanelTop">
            <div style="position: absolute;top: 25px;left: 175px;">
                <div id="amenities"></div>
            </div>
        </div>
        <div id="searchPanel">
            <div style="position: absolute; top:100px; left:200px;">
                <div id="sliderdiv">
                    <div id="price_slider" style="display: none;"></div>
                </div>
            </div>

        </div>
    </div>

    <script>

        const filtersDiv = document.getElementById("filtersDiv");
        const infoDiv = document.getElementById("info");
        const amenitiesDiv = document.getElementById("amenities");
        const priceSlider = document.getElementById('price_slider');

        // const releasePopups = [];

        const activeAmenities = [];
        const mainData = {};
        const fetchOptions = {
            cache: "force-cache"
        }
        const filters = {
            price: {
                min: 0,
                max: 0
            },
            room: [],
            storey: [],
            available: []
        }

        const urlProps = {};
        mapboxgl.accessToken = 'pk.eyJ1Ijoic2Vyc2Vyc2VyIiwiYSI6ImNrZnBpaWF5azBpMWMyeHBmdzJpdno1NzgifQ.4vBDF2DNuk-beXljllf3Yg';
        var map = new mapboxgl.Map({
            container: 'map', // container ID
            style: 'mapbox://styles/mapbox/streets-v11', // style URL
            center: { lng: 150.75354376408677, lat: -33.76180832669016 },
            zoom: 16 // starting zoom
        });
        map.addControl(new mapboxgl.NavigationControl());

        var releasesSatetId = null;
        var hoveredStateId = null;
        var clickedStateId = null;

        var popup = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false
        });


        noUiSlider.create(priceSlider, {
            start: [100000, 1000000],
            connect: true,
            tooltips: [wNumb({ decimals: 0, thousand: ",", prefix: '$' }), wNumb({ decimals: 0, thousand: ",", prefix: '$' })],
            range: {
                'min': 100000,
                'max': 1000000
            }
        });
        priceSlider.noUiSlider.on('set.one', function (values) {
            console.log('values', values);
            filters.price.min = +values[0]
            filters.price.max = +values[1]
            updateLotsGeometry()
        });

        mergeTooltips(priceSlider, 35, ' - ');


        function updateLotsGeometry(skipPriceFilter) {

            if (!mainData || !mainData.lots) return;

            const pins = [];

            //reset hilighting 
            mainData.lots.forEach(i => {
                map.setFeatureState(
                    { source: 'lots', id: i.Lot_Number },
                    { active: false }
                );
            })

            //AFTER CLEAR ALL, do not apply any other filters, just clear the data. for CLEAR FILTER BUTTON 
            if (
                filters.price.min === 0 &&
                filters.price.max === 0 &&
                filters.room.length === 0 &&
                filters.storey.length === 0 &&
                filters.available.length === 0
            ) {
                return;
            }

            const lotsGeometry = mainData.lots
                .filter(i => i.Lot_Polygon_Data !== "")
                //ROOMS FILTER
                .filter(i => {
                    if (filters.room && filters.room.length > 0) {
                        if (filters.room.includes(i['Lot_Bedrooms'])) {
                            return i
                        }
                    } else {
                        return i
                    }
                })
                //ROOMS FILTER
                .filter(i => {
                    if (filters.storey && filters.storey.length > 0) {
                        const lotLevel = (+i['Lot_Storeys'] === 2) ? 'double' : 'single'
                        if (filters.storey.includes(lotLevel)) {
                            return i
                        }
                    } else {
                        return i
                    }
                })
                //Available FILTER
                .filter(i => {
                    if (filters.storey && filters.available.length > 0) {
                        const lotStatus = i['Lot_Status'].toLowerCase()
                        if (filters.available.includes(lotStatus)) {
                            return i
                        }
                    } else {
                        return i
                    }
                })
                //PRICE FILTER
                .filter(i => {

                    if (filters && filters.price && filters.price.max > 0) {
                        const { min, max } = filters.price
                        const price = +i.Lot_Price
                        if (price >= +min && price <= +max) {
                            return i
                        }
                    } else {
                        return i
                    }
                })
                .map(i => {

                    const lot = JSON.parse(i.Lot_Polygon_Data);
                    lot.properties.color = i['Lot_Indicator_Colour'];
                    lot.properties.webHook = i['Lot_Webhook'];
                    lot.id = i.Lot_Number

                    map.setFeatureState(
                        { source: 'lots', id: i.Lot_Number },
                        { active: true }
                    );

                    const pinLatlng = [+i.Lot_Longitude, +i.Lot_Latitude];
                    pins.push({
                        "type": "Feature",
                        "properties": {},
                        "geometry": {
                            "type": "Point",
                            "coordinates": pinLatlng
                        },
                        properties: {
                            color: i['Lot_Indicator_Colour'],
                        }
                    })

                    return lot
                })


            console.log('Updated lotsGeometry', lotsGeometry);
        }

        function addremoveFromArray(array, value) {
            const index = array.indexOf(value)
            if (index === -1) { //not found, add
                array.push(value)
            } else { //already exists, remove
                array.splice(index, 1)
            }
        }

        getUrlParams();
        document.addEventListener("click", e => {

            if (e.target.classList.contains("am")) {
                console.log('amenity category clicked');
                let unselect = false;
                const amId = +e.target.getAttribute("am_id")
                const index = activeAmenities.indexOf(amId);
                let clickedIndex;
                if (index > -1) {
                    activeAmenities.splice(index, 1);
                    unselect = true
                } else {
                    activeAmenities.push(amId)
                }
                console.log('amId', amId);
                const am = mainData.amenities.find(i => +i['Amenity_Cat_ID'] === +amId)
                if (am) {
                    const center = [+am['Amenity_Cat_Longitude'], +am['Amenity_Cat_Latitude']]
                    const zoom = [am['Amenity_Cat_Zoom']]

                    if (!unselect) {

                        webHook(am['Amenity_Cat_Webhook'])
                        map.flyTo({
                            center,
                            zoom
                        })
                    }
                }

                updateAmenities();
                updateAmenitiesDiv()
            }
        })

        // document.addEventListener("mousedown", e => {
        //     console.log('123', 123);
        //     if (e.target.classList.contains("am")) {

        //     }
        // })

        function createButton({
            layerId,
            position,
            imgSize,
            callbackAction,
            imgSrc,
            imgMouseDown,
            imgHover,
            className,
            action,
            buttonType
        }) {

            let currentState = false;
            const { top, right, left } = position;
            var div = document.createElement('div');
            div.className = "custom";
            div.style.position = "absolute";
            div.style.top = top + "px";

            console.log('right', right);
            console.log('left', left);
            if (right) {
                div.style.right = right + "px";
            }
            if (left) {
                div.style.left = left + "px";
            }

            div.style.zIndex = 1000;

            var img = document.createElement('img');
            img.setAttribute("src", imgSrc);
            img.setAttribute("class", className);
            img.setAttribute("action", action);
            img.style.width = imgSize.width + "px"
            img.style.height = imgSize.height + "px"
            //events
            img.onclick = callbackAction;
            img.onmousedown = function (e) {
                img.setAttribute("src", imgMouseDown);
            }
            img.onmouseup = function (e) {
                console.log('currentState', currentState);
                if (buttonType && buttonType === "toggle") {
                    if (!currentState) {
                        img.setAttribute("src", imgMouseDown);
                    } else {
                        img.setAttribute("src", imgSrc);
                    }
                    currentState = !currentState
                } else {
                    img.setAttribute("src", imgSrc);
                }
            }
            div.appendChild(img)
            document.getElementById(layerId).appendChild(div)


            function reset() {//set initial values;
                currentState = false;
                img.setAttribute("src", imgSrc);
            }

            return {
                img,
                reset: reset
            };
        }

        //==================================================BUTTONS======================================================
        //==================================================BUTTONS======================================================
        //==================================================BUTTONS======================================================

        const menuButtons = [
            {
                layerId: "mainSearchPanel",
                position: { top: 50, right: 950 },
                imgSize: { width: 100, height: 100 },
                callbackAction: function () {
                    map.flyTo({
                        zoom: map.getZoom() + 1
                    })
                },
                imgSrc: 'img/zoomin.png',
                imgMouseDown: "img/zoomin_active.png",
                imgHover: "",
                className: "search-icon action",
                action: ""
            },

            {
                layerId: "mainSearchPanel",
                position: { top: 50, right: 750 },
                imgSize: { width: 100, height: 100 },
                callbackAction: function () {
                    map.flyTo({
                        zoom: map.getZoom() - 1
                    })
                },
                imgSrc: 'img/zoomout.png',
                imgMouseDown: "img/zoomout_active.png",
                imgHover: "",
                className: "search-icon action",
                action: ""
            },

            {
                buttonType: "toggle",
                position: { top: 25, left: 760 },
                imgSize: { width: 150, height: 150 },
                layerId: "searchPanel",
                callbackAction: function () {
                    addremoveFromArray(filters.room, 3)
                    updateLotsGeometry()
                },
                imgSrc: 'img/3BR.png',
                imgMouseDown: "img/3BR_active.png",
                imgHover: "img/3BR_active.png",
                className: "search-icon action",
                action: ""
            },
            {
                buttonType: "toggle",
                position: { top: 25, left: 920 },
                imgSize: { width: 150, height: 150 },
                layerId: "searchPanel",
                callbackAction: function () {
                    addremoveFromArray(filters.room, 4)
                    updateLotsGeometry()
                },
                imgSrc: 'img/4BR.png',
                imgMouseDown: "img/4BR_active.png",
                imgHover: "img/4BR_active.png",
                className: "search-icon action",
                action: ""
            },

            {
                buttonType: "toggle",
                position: { top: 25, left: 1100 },
                imgSize: { width: 150, height: 150 },
                layerId: "searchPanel",
                callbackAction: function () {
                    addremoveFromArray(filters.storey, 'single')
                    updateLotsGeometry()
                },
                imgSrc: 'img/single_storey.png',
                imgMouseDown: "img/single_storey_active.png",
                className: "search-icon action",
                action: ""
            },

            {
                buttonType: "toggle",
                position: { top: 25, left: 1260 },
                imgSize: { width: 150, height: 150 },
                layerId: "searchPanel",
                callbackAction: function () {
                    addremoveFromArray(filters.storey, 'double')
                    updateLotsGeometry()
                },
                imgSrc: 'img/double_storey.png',
                imgMouseDown: "img/double_storey_active.png",
                className: "search-icon action",
                action: ""
            },

            {//all_available
                buttonType: "toggle",
                position: { top: 25, left: 1420 },
                imgSize: { width: 150, height: 150 },
                layerId: "searchPanel",
                callbackAction: function () {
                    addremoveFromArray(filters.available, 'available')
                    updateLotsGeometry()
                },
                imgSrc: 'img/all_available.png',
                imgMouseDown: "img/all_available_active.png",
                className: "search-icon action",
                action: ""
            },

            { //CLEAR FILTERS BUTTON
                // buttonType: "toggle",
                position: { top: 25, left: 1600 },
                imgSize: { width: 150, height: 150 },
                layerId: "searchPanel",
                callbackAction: function () {
                    clearFilters()
                    updateLotsGeometry()
                },
                imgSrc: 'img/clear_filter.png',
                imgMouseDown: "img/clear_filter_mousedown.png",
                className: "search-icon action",
                action: ""
            },


            {
                // buttonType: "toggle",
                position: { top: 25, left: 10 },
                imgSize: { width: 150, height: 150 },
                layerId: "searchPanel",
                callbackAction: function () {
                    searchPanelTop.style.height = "200px";
                    searchPanel.style.height = "0px"
                    fetch('https://api.intuiface.com/webtriggers/v1/sendMessage?message=searchinactive&playerTags=kingscentralmap&apikey=b58eded3-1d8b-40f3-8908-9d93335832bc')
                },
                imgSrc: 'img/return.png',
                imgMouseDown: "img/return.png",
                className: "search-icon action",
                action: ""
            },

            {
                // buttonType: "toggle",
                position: { top: 25, left: 10 },
                imgSize: { width: 150, height: 150 },
                layerId: "searchPanelTop",
                callbackAction: function () {
                    searchPanelTop.style.height = "0px";
                    searchPanel.style.height = "200px";
                    fetch('https://api.intuiface.com/webtriggers/v1/sendMessage?message=searchactive&playerTags=kingscentralmap&apikey=b58eded3-1d8b-40f3-8908-9d93335832bc')

                    console.log('home search',);

                    map.flyTo({
                        center: [
                            +mainData.admin['Project_Longitude'],
                            +mainData.admin['Project_Latitude']
                        ],
                        zoom: +mainData.admin['Project_Zoom_Level']
                    })
                },
                imgSrc: 'img/homes_search.png',
                imgMouseDown: "img/homes_search.png",
                className: "search-icon action",
                action: ""
            }
        ]

        const buttonsArray = menuButtons.map(i => {
            return createButton(i);
        })

        //==================================================BUTTONS======================================================
        //==================================================BUTTONS======================================================
        //==================================================BUTTONS======================================================

        function clearFilters() {
            console.log('clearFilters',);

            buttonsArray.forEach(button => {//reset buttons state
                button.reset();
            })

            const { min, max } = priceSlider.noUiSlider.options.range;
            priceSlider.noUiSlider.set([min, max])

            filters.price.min = 0
            filters.price.max = 0
            filters.room.length = 0
            filters.storey.length = 0
            filters.available.length = 0
        }

        function updateAmenitiesDiv() {

            amenitiesDiv.innerHTML = "";

            const am = Object.keys(mainData.amenitiesDiv)
                .map(i => {
                    console.log('i', i);
                    if (!activeAmenities.includes(+i)) { // if not enabled set icon to OFF 
                        // console.log('OFF');
                        icon = mainData.amenitiesDiv[i].off
                        img = mainData.amenitiesDiv[i].offimg
                    } else {

                        icon = mainData.amenitiesDiv[i].on
                        img = mainData.amenitiesDiv[i].onimg
                    }
                    amenitiesDiv.appendChild(img);
                })

            map.setFilter('amenitiesicon', ['in', ['get', 'amId'], ["literal", activeAmenities]]);
        }

        function updateAmenities(Amenity_ID) {

            console.log('activeAmenities', activeAmenities);
            console.log('Amenity_ID', Amenity_ID);

            const amLilst = mainData.amenitiesList
                .map(i => {
                    const latlng = [+i['Amenity Longitude'], +i['Amenity_Latitude']];
                    let icon;

                    if (Amenity_ID && Amenity_ID === i.Amenity_ID) {
                        icon = i['Amenity_Category_Name']
                    } else {
                        icon = i['Amenity_Category_Name'] + "_off"
                    }

                    return {
                        "type": "Feature", "properties": {},
                        "geometry": {
                            "type": "Point",
                            "coordinates": latlng
                        },
                        properties: {
                            ...i,
                            icon: icon,
                            amId: +i['Amenity_Category_ID']
                        }
                    };
                })
            const collection = {
                "type": "FeatureCollection",
                "features": amLilst
            };
            map.getSource("amenities").setData(collection)
        }


        map.on('load', async function () {

            //ADMIN PARAMS
            //await?
            getObject('object_11').then(data => {
                console.log('ADMIN PARAMS ', data);
                mainData.admin = data[0]

                if (mainData.admin['Project_Zoom_Level']) {
                    console.log('!!!!!!!!!!!!!!!!!!!!');
                    map.flyTo({
                        center: [
                            +mainData.admin['Project_Longitude'],
                            +mainData.admin['Project_Latitude']
                        ],
                        zoom: +mainData.admin['Project_Zoom_Level']
                    })
                }

                if (mainData.admin && mainData.admin['Lot_Boundary_MinZoom']) {
                    const minZoom = +mainData.admin['Lot_Boundary_MinZoom'];
                    const maxZoom = +mainData.admin['Lot Boundary_MaxZoom'];
                    const lotsLayers = [
                        'lots-fills',
                        'lots-active',
                        'lots-borders',
                        'lots-pins',
                    ].forEach(i => {
                        map.setLayerZoomRange(i, minZoom, maxZoom);
                    })
                }

                if (mainData.admin && mainData.admin['Lot_Boundary_MinZoom']) {
                    //Release_Boundary_MaxZoom: "17.407400705603479"
                    //Release_Boundary_MinZoom: "14.288423362730992"
                    const minZoom = +mainData.admin['Release_Boundary_MinZoom'];
                    const maxZoom = +mainData.admin['Release_Boundary_MaxZoom'];
                    const lotsLayers = [
                        'releases-fills',
                        'releases-borders',
                    ].forEach(i => {
                        map.setLayerZoomRange(i, minZoom, maxZoom);
                    })
                }


                //project_image
                if (mainData.admin['Project_Label_Active'].toLowerCase() === "yes") {
                    const projectImageCoords = [+mainData.admin['Project_Label_Longitude'], +mainData.admin['Project_Label_Latitude']]
                    let projectImage = mainData.admin['Project_Label_Image'];
                    projectImage = (new DOMParser()).parseFromString(projectImage, 'text/html').querySelector('img');
                    projectImage = projectImage.src;
                    map.loadImage(projectImage, function (error, image) {
                        map.addImage('project_label', image);
                    })
                    const projectImageJSON = {
                        "type": "Feature", "properties": {},
                        "geometry": {
                            "type": "Point",
                            "coordinates": projectImageCoords
                        },
                        'properties': {
                            icon: 'project_label',
                        }
                    };
                    const collection = {
                        "type": "FeatureCollection",
                        "features": [projectImageJSON]
                    };
                    console.log('collection', collection);
                    map.getSource("project_image").setData(collection)
                    map.setLayerZoomRange('project_image', +mainData.admin['Project_Label_MinZoom'], +mainData.admin['Project_Label_MaxZoom']);
                }


                
                map.setLayoutProperty("amenitiesicon", "icon-size", JSON.parse(mainData.admin.Amenity_External_Icon_Interpolate))
                map.setLayoutProperty("amenitiesiconInternal", "icon-size", JSON.parse(mainData.admin.Amenity_Internal_Icon_Interpolate))
            })


            //get RELEASES data
            getObject('object_3').then(json => {

                console.log('RELEASES', json);

                mainData.releases = [];
                mainData.releases.push(...json)
                const data = json.filter(i => i['Release_Polygon_Active'].toLowerCase() === "true") //filter by Lot_Polygon_Active


                const releases = data
                    .filter(i => i.Release_Polygon_Data !== "")
                    .map(i => {
                        const geometry = JSON.parse(i.Release_Polygon_Data);
                        geometry.id = i.Release_ID
                        geometry.properties.webHook = i.Release_Webhook;
                        geometry.properties.lat = +i.Release_Centre_Lat;
                        geometry.properties.lng = +i.Release_Centre_Long;
                        geometry.properties.zoom = +i.Release_Centre_Zoom_Level;
                        return geometry
                    })

                console.log('releases++++', releases);

                map.getSource("releases").setData({
                    "type": "FeatureCollection",
                    "features": releases
                })

                //URL PARAMS
                if (urlProps.releaseid && urlProps.releaseid > 0) {
                    const c = data.find(i => +i['Release_ID'] === +urlProps.releaseid)
                    if (c) {
                        map.flyTo({
                            center: [c.Lot_Longitude, +c.Lot_Latitude],
                            zoom: urlProps.zoom
                        })
                    }
                }

            })


            //get LOTS data
            getObject('object_1').then(json => {

                console.log('json', json);

                mainData.lots = [];
                mainData.lots.push(...json)

                const data = json.filter(i => i['Lot_Polygon_Active'].toLowerCase() === "true") //filter by Lot_Polygon_Active

                let bounds = new mapboxgl.LngLatBounds();
                const pins = data
                .filter(i => i['Lot_Status'].toLowerCase() === "sold")
                .map(i => {

                    const latlng = [+i.Lot_Longitude, +i.Lot_Latitude];
                    bounds.extend(latlng)

                    return {
                        "type": "Feature",
                        "properties": {},
                        "geometry": {
                            "type": "Point",
                            "coordinates": latlng
                        },
                        properties: {
                            color: i['Lot_Indicator_Colour'],
                        }
                    };
                })

                console.log('pins', pins);
                map.getSource("pins").setData({
                    "type": "FeatureCollection",
                    "features": pins
                })

                const lotsGeometry = data
                    .filter(i => i.Lot_Polygon_Data !== "")
                    .map(i => {
                        const lot = JSON.parse(i.Lot_Polygon_Data);
                        lot.properties.color = i['Lot_Indicator_Colour'];
                        lot.properties.webHook = i['Lot_Webhook'];
                        lot.id = i.Lot_Number
                        // console.log('lot', lot);
                        return lot
                    })

                console.log('lotsGeometry', lotsGeometry);

                map.getSource("lots").setData({
                    "type": "FeatureCollection",
                    "features": lotsGeometry
                })


                //URL PARAMS
                if (urlProps.lotid && urlProps.lotid > 0) {
                    const c = data.find(i => +i['LOT_ID'] === +urlProps.lotid)
                    if (c) {
                        map.flyTo({
                            center: [c.Lot_Longitude, +c.Lot_Latitude],
                            zoom: urlProps.zoom
                        })
                    }
                }

                if (urlProps.lotactive && urlProps.lotactive.length > 0) {
                    const lots = urlProps.lotactive.split(",")
                    lots.forEach(i => {

                        const lotId = +i
                        map.setFeatureState(
                            { source: 'lots', id: lotId },
                            { active: true }
                        );

                    })
                }

            })

            //amenities categories with icons
            getObject('object_7').then(json => {
                const am = [];
                mainData.amenities = [];
                mainData.amenitiesDiv = {};
                json
                    //.filter(i => i['Amenity_Cat_Type'] === "External") // only External amenities should be on bottom tab
                    .map(i => {

                        const onIcon = i['Amenity_Cat_IconActive'];
                        const offIcon = i['Amenity_Cat_IconInactive'];

                        var imgOn = (new DOMParser()).parseFromString(onIcon, 'text/html').querySelector('img');
                        const srcOn = imgOn.src;

                        var imgOff = (new DOMParser()).parseFromString(offIcon, 'text/html').querySelector('img');
                        const srcOff = imgOff.src;

                        var on = document.createElement("IMG");
                        on.setAttribute("src", srcOn);
                        on.setAttribute("am_id", i.Amenity_Cat_ID);
                        on.setAttribute("class", "am");

                        var off = document.createElement("IMG");
                        off.setAttribute("src", srcOff);
                        off.setAttribute("am_id", i.Amenity_Cat_ID);
                        off.setAttribute("class", "am");

                        if (i['Amenity_Cat_Type'] === "External") {//for div use only External
                            mainData.amenitiesDiv[i.Amenity_Cat_ID] = {
                                on: srcOn,
                                off: srcOff,
                                onimg: on,
                                offimg: off,
                            };
                        }

                        mainData.amenities.push(i)

                        //loading icons for amenities
                        map.loadImage(srcOn, function (error, image) {
                            // console.log('srcOn', srcOn);
                            map.addImage(i['Amenity_Cat_Name'], image);
                        })
                        map.loadImage(srcOff, function (error, image) {
                            // console.log('srcOff', srcOff);
                            map.addImage(i['Amenity_Cat_Name'] + "_off", image);
                        })
                    })

                //-------------URL FILTER PART-----------------------
                //if ?amenitylist=false do not show amenities
                //if ?amenitylist=1,2,3 etc show only this amenities
                //if not defined show all
                console.log('urlProps.amenityList', urlProps.amenityList);
                let aFilter = [];
                if (urlProps.amenityList && urlProps.amenityList.length > 0) {
                    aFilter = urlProps.amenityList.split(",").map(i => +i);
                    activeAmenities.push(...aFilter);
                } else {
                    activeAmenities.push(...json.map(i => +i.Amenity_Cat_ID))
                }
                map.setFilter('amenitiesicon', ['in', ['get', 'amId'], ["literal", activeAmenities]]);
                //-------------URL FILTER PART-----------------------

                updateAmenitiesDiv()
            })

            //POPUP TOOLTIPS FOR RELEASES
            //getObject('object_9').then(data => {

            // console.log('Amenity', data);


            //})


            //list of amenities
            getObject('object_9').then(data => {

                console.log('Amenity', data);

                // data = data

                mainData.amenitiesList = data.filter(i => i.Amenity_Type === "External");
                mainData.amenitiesListInternal = data.filter(i => i.Amenity_Type === "Internal");


                //URL PARAMS
                let aFilter = [];
                if (urlProps.amenityList && urlProps.amenityList.length > 0) {
                    aFilter = urlProps.amenityList.split(",").map(i => +i);
                }

                console.log('aFilter', aFilter);

                const [minZoomExternal, maxZoomExternal] = [
                    mainData.amenitiesList[0]['Amenity_Min_Zoom'],
                    mainData.amenitiesList[0]['Amenity_Max_Zoom']
                ]
                //now it is controled by Amenity_External_Icon_Interpolate
                //map.setLayerZoomRange("amenitiesicon", minZoomExternal, maxZoomExternal);//set min max  zoom level  for amenitiesicon

                const amLilst = mainData.amenitiesList
                    .map(i => {
                        const latlng = [+i['Amenity Longitude'], +i['Amenity_Latitude']];
                        return {
                            "type": "Feature", "properties": {},
                            "geometry": {
                                "type": "Point",
                                "coordinates": latlng
                            },
                            properties: {
                                ...i,
                                icon: i['Amenity_Category_Name'],
                                amId: +i['Amenity_Category_ID']
                            }
                        };
                    })

                const collection = {
                    "type": "FeatureCollection",
                    "features": amLilst
                };
                console.log('c', collection);
                map.getSource("amenities").setData(collection)
                map.setLayoutProperty("amenitiesicon", "icon-size", JSON.parse(mainData.admin.Amenity_External_Icon_Interpolate))

                //==== INTERNAL =====


                const [minZoomInternal, maxZoomInternal] = [
                    mainData.amenitiesListInternal[0]['Amenity_Min_Zoom'],
                    mainData.amenitiesListInternal[0]['Amenity_Max_Zoom']
                ]

                //map.setLayerZoomRange("amenitiesiconInternal", minZoomInternal, maxZoomInternal);//set min max  zoom level  for amenitiesiconInternal
                console.log('JSON.stringify()', JSON.stringify(mainData.admin));


                const amLilstInternal = mainData.amenitiesListInternal
                    .map(i => {
                        const latlng = [+i['Amenity Longitude'], +i['Amenity_Latitude']];
                        return {
                            "type": "Feature", "properties": {},
                            "geometry": {
                                "type": "Point",
                                "coordinates": latlng
                            },
                            properties: {
                                ...i,
                                icon: i['Amenity_Category_Name'] + "_off",
                                amId: +i['Amenity_Category_ID']
                            }
                        };
                    })
                console.log('amLilstInternal', amLilstInternal);
                map.getSource("amenitiesInternal").setData({
                    "type": "FeatureCollection",
                    "features": amLilstInternal
                })
                map.setLayoutProperty("amenitiesiconInternal", "icon-size", JSON.parse(mainData.admin.Amenity_Internal_Icon_Interpolate))
                //==== INTERNAL =====



                //URL PARAMS
                if (urlProps.amenityid && urlProps.amenityid > 0) {
                    const c = data.find(i => +i['Amenity_ID'] === +urlProps.amenityid)
                    if (c) {
                        map.flyTo({
                            center: [c['Amenity Longitude'], +c.Amenity_Latitude],
                            zoom: urlProps.zoom
                        })
                    }
                }


            })
            map.addSource("myImageSource", {
                "type": "image",
                "url": "Kings-Central---Masterplan_FA_final_edit3-01_modified_____24.png",
                "coordinates": [
                    [150.746548419, -33.757439695], [150.759636543, -33.757439695], [150.759636543, -33.764958904], [150.746548419, -33.764958904]
                ]
            });
            map.addLayer({
                "id": "overlay",
                "source": "myImageSource",
                "type": "raster",
                "paint": {
                    "raster-opacity": 0.85
                }
            });

            //RELEASES
            map.addSource('releases', { //mapbox source for geojson data
                'type': 'geojson',
                'data': {
                    "type": "FeatureCollection",
                    "features": []
                }
            });
            map.addLayer({
                'id': 'releases-fills',
                'type': 'fill',
                'source': 'releases',
                'layout': {},
                'paint': {
                    'fill-color': 'red',
                    'fill-opacity': [
                        'case',
                        ['boolean', ['feature-state', 'hover'], false],
                        0.5,
                        0.
                    ]
                }
            });
            map.addLayer({
                'id': 'releases-borders',
                'type': 'line',
                'source': 'releases',
                'layout': {},
                'paint': {
                    'line-color': 'white',
                    'line-width': 2,
                    'line-opacity': 1
                }
            });

            //Project_Label_Image
            map.addSource('project_image', {
                "type": "geojson",
                "data": {
                    "type": "FeatureCollection",
                    "features": []
                }
            });
            map.addLayer({
                'id': 'project_image',
                'source': 'project_image',
                'type': 'symbol',
                'layout': {
                    'icon-image': ['get', 'icon'],
                    'icon-allow-overlap': true,
                    'icon-ignore-placement': true,
                    'icon-size': 1
                }
            });



            map.addSource('amenities', {
                "type": "geojson",
                "data": {
                    "type": "FeatureCollection",
                    "features": []
                }
            });
            map.addLayer({
                'id': 'amenitiesicon',
                'source': 'amenities',
                'type': 'symbol',
                'layout': {
                    'icon-image': ['get', 'icon'],
                    'icon-allow-overlap': true,
                    'icon-ignore-placement': true,
                    'icon-size': 0.5
                }
            });

            map.addSource('amenitiesInternal', {
                "type": "geojson",
                "data": {
                    "type": "FeatureCollection",
                    "features": []
                }
            });
            map.addLayer({
                'id': 'amenitiesiconInternal',
                'source': 'amenitiesInternal',
                'type': 'symbol',
                'layout': {
                    'icon-image': ['get', 'icon'],
                    'icon-allow-overlap': true,
                    'icon-ignore-placement': true,
                    //'icon-size': 0.5,

                    "icon-size": ['interpolate',
                        ['linear'],
                        ['zoom'],
                        10, 0.1,
                        15, 0.1,
                        16, 0.1,
                        17, 0.5,
                        22, 0.5
                    ]
                }
            });
            // map.addLayer({
            //     'id': 'population',
            //     'type': 'circle',
            //     'source': 'amenitiesInternal',
            //     'paint': {
            //         'circle-radius': {
            //             'base': 1.75,
            //             'stops': [
            //                 [12, 2],
            //                 [22, 180]
            //             ]
            //         },
            //         'circle-color': 'red'
            //     }
            // });


            map.addSource('lots', { //mapbox source for geojson data
                'type': 'geojson',
                'data': {
                    "type": "FeatureCollection",
                    "features": []
                }
            });

            map.addLayer({
                'id': 'lots-fills',
                'type': 'fill',
                'source': 'lots',
                'layout': {},
                minZoom: 22,//init zoom, to remove flickering while waiting for admin vars to load
                'paint': {
                    'fill-color': ['get', 'color'],
                    'fill-opacity': [
                        'case',
                        ['boolean', ['feature-state', 'hover'], false],
                        0.5,
                        0
                    ]
                }
            });
            map.addLayer({
                'id': 'lots-active',
                'type': 'fill',
                'source': 'lots',
                'layout': {},
                minZoom: 22,//init zoom, to remove flickering while waiting for admin vars to load
                'paint': {
                    'fill-color': ['get', 'color'],
                    'fill-opacity': [
                        'case',
                        ['boolean', ['feature-state', 'active'], false],
                        0.5,
                        0
                    ]
                }
            });
            map.addLayer({
                'id': 'lots-borders',
                'type': 'line',
                'source': 'lots',
                minZoom: 22,//init zoom, to remove flickering while waiting for admin vars to load
                'layout': {},
                'paint': {
                    'line-color': 'white',
                    'line-width': 2
                }
            });
            map.addSource('pins', {
                "type": "geojson",
                "data": {
                    "type": "FeatureCollection",
                    "features": []
                }
            });
            map.addLayer({
                'id': 'lots-pins',
                'type': 'circle',
                'source': 'pins',
                minZoom: 22,//init zoom, to remove flickering while waiting for admin vars to load
                'paint': {
                    'circle-radius': 8,
                    'circle-color': ['get', 'color'],
                    'circle-stroke-color': 'white',
                    'circle-stroke-width': 1
                }
            });


            //==================RELEASES======================================
            map.on('click', 'releases-fills', function (e) {
                console.log('e.features[0]', e.features[0]);
                const props = e.features[0].properties;
                if (e.features.length > 0) {
                    if (clickedStateId) {
                        map.setFeatureState(
                            { source: 'releases', id: clickedStateId },
                            { active: false }
                        );
                    }
                    clickedStateId = e.features[0].id;
                    map.setFeatureState(
                        { source: 'releases', id: clickedStateId },
                        { active: true }
                    );
                }
                map.flyTo({
                    center: [props.lng, props.lat],
                    zoom: props.zoom
                })
                webHook(e.features[0].properties['webHook'])
            });
            map.on('mousemove', 'releases-fills', function (e) {
                if (e.features.length > 0) {
                    if (releasesSatetId) {
                        map.setFeatureState(
                            { source: 'releases', id: releasesSatetId },
                            { hover: false }
                        );
                    }
                    releasesSatetId = e.features[0].id;
                    map.setFeatureState(
                        { source: 'releases', id: releasesSatetId },
                        { hover: true }
                    );
                }
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'releases-fills', function () {
                if (releasesSatetId) {
                    map.setFeatureState(
                        { source: 'releases', id: releasesSatetId },
                        { hover: false }
                    );
                }
                releasesSatetId = null;
                map.getCanvas().style.cursor = '';
            });


            //==================project_image======================================
            map.on('click', 'project_image', function (e) {
                console.log('e', e);
                const webhook = mainData.admin.Project_Webhook;
                fetch(webhook)
                map.flyTo({
                    center: [+mainData.admin['Project_Longitude'], +mainData.admin['Project_Latitude']],
                    zoom: +mainData.admin['Project_Zoom_Level']
                })
            });
            map.on('mousemove', 'project_image', function (e) {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'project_image', function () {
                map.getCanvas().style.cursor = '';
            });

            //==================amenities======================================
            map.on('click', 'amenitiesicon', function (e) {

                console.log('e.features[0]', e.features[0]);
                const webhook = e.features[0].properties['Amenity_Webhook'];
                const Amenity_ID = e.features[0].properties['Amenity_ID'];
                console.log('webhook', webhook);
                webHook(webhook)
                updateAmenities(Amenity_ID)
            });

            map.on('mousemove', 'amenitiesicon', function (e) {
                map.getCanvas().style.cursor = 'pointer';
            });

            // When the mouse leaves the state-fill layer, update the feature state of the
            // previously hovered feature.
            map.on('mouseleave', 'amenitiesicon', function () {
                map.getCanvas().style.cursor = '';
            });

            //==================amenities INTERNAL======================================
            map.on('click', 'amenitiesiconInternal', function (e) {

            });

            map.on('mousedown', 'amenitiesiconInternal', function (e) {

                console.log('e.features[0]', e.features[0]);
                const webhook = e.features[0].properties['Amenity_Webhook'];
                const Amenity_ID = e.features[0].properties['Amenity_ID'];
                console.log('webhook', webhook);
                webHook(webhook)
                //updateAmenities(Amenity_ID)

                const amLilst = mainData.amenitiesListInternal
                    .map(i => {
                        const latlng = [+i['Amenity Longitude'], +i['Amenity_Latitude']];
                        let icon;

                        if (Amenity_ID && Amenity_ID === i.Amenity_ID) {
                            icon = i['Amenity_Category_Name']
                        } else {
                            icon = i['Amenity_Category_Name'] + "_off"
                        }
                        return {
                            "type": "Feature", "properties": {},
                            "geometry": {
                                "type": "Point",
                                "coordinates": latlng
                            },
                            properties: {
                                ...i,
                                icon: icon,
                                amId: +i['Amenity_Category_ID']
                            }
                        };
                    })
                const collection = {
                    "type": "FeatureCollection",
                    "features": amLilst
                };
                map.getSource("amenitiesInternal").setData(collection)

            });
            map.on('mouseup', 'amenitiesiconInternal', function (e) {
                //ALL ICONS OFF
                const amLilst = mainData.amenitiesListInternal
                    .map(i => {
                        const latlng = [+i['Amenity Longitude'], +i['Amenity_Latitude']];
                        return {
                            "type": "Feature", "properties": {},
                            "geometry": {
                                "type": "Point",
                                "coordinates": latlng
                            },
                            properties: {
                                ...i,
                                icon: i['Amenity_Category_Name'] + "_off",
                                amId: +i['Amenity_Category_ID']
                            }
                        };
                    })
                const collection = {
                    "type": "FeatureCollection",
                    "features": amLilst
                };
                map.getSource("amenitiesInternal").setData(collection)
            });

            map.on('mousemove', 'amenitiesiconInternal', function (e) {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'amenitiesiconInternal', function () {
                map.getCanvas().style.cursor = '';
            });

            //==================LOTS======================================
            map.on('click', 'lots-active', function (e) {
                console.log('e.features[0]', e.features[0]);
                if (e.features.length > 0) {
                    if (clickedStateId) {
                        map.setFeatureState(
                            { source: 'lots', id: clickedStateId },
                            { active: false }
                        );
                    }
                    clickedStateId = e.features[0].id;
                    map.setFeatureState(
                        { source: 'lots', id: clickedStateId },
                        { active: true }
                    );
                }
                webHook(e.features[0].properties['webHook'])
            });

            map.on('mousemove', 'lots-fills', function (e) {
                if (e.features.length > 0) {
                    if (hoveredStateId) {
                        map.setFeatureState(
                            { source: 'lots', id: hoveredStateId },
                            { hover: false }
                        );
                    }
                    hoveredStateId = e.features[0].id;
                    map.setFeatureState(
                        { source: 'lots', id: hoveredStateId },
                        { hover: true }
                    );
                }
                map.getCanvas().style.cursor = 'pointer';
            });

            // When the mouse leaves the state-fill layer, update the feature state of the
            // previously hovered feature.
            map.on('mouseleave', 'lots-fills', function () {
                if (hoveredStateId) {
                    map.setFeatureState(
                        { source: 'lots', id: hoveredStateId },
                        { hover: false }
                    );
                }
                hoveredStateId = null;
                map.getCanvas().style.cursor = '';
            });


            // When the user moves their mouse over the state-fill layer, we'll update the
            // feature state for the feature under the mouse.
            map.on('mousemove', 'lots-pins', function (e) {
                map.getCanvas().style.cursor = 'pointer';
            });

            map.on('moveend', () => {

                getInfo();
            })
            map.on('click', (e) => {
                if (urlProps.debugMode) {
                    console.log('e', e);
                    var popup = new mapboxgl.Popup({ closeOnClick: false })
                        .setLngLat(e.lngLat)
                        .setHTML(`
                ${e.lngLat}
                    <br>
                        zoom: ${map.getZoom()}
            `)
                        .addTo(map);
                }
            })

            function getInfo() {
                const c = map.getCenter();
                const z = map.getZoom();
                infoDiv.innerHTML = `center: ${c}<br>zoom: ${z}`;
            }
        });

        function webHook(url) {
            console.log('url', url);
            if (!url || url === "") return;
            var a = (new DOMParser()).parseFromString(url, 'text/html').querySelector('a');
            const href = a.href;
            console.log('href', href);
            fetch(href)
        }
        //===============KNACK=======================
        //===============KNACK=======================
        //===============KNACK=======================

        async function getObject(objectId) {

            const knack_id = '6036576bc14450001b52154b';
            const knack_key = '40b03503-348a-42da-a099-4b3b16d6a10d';
            let keys = [];
            let res = [];

            await fetch('https://api.knackhq.com/v1/objects/' + objectId + '/fields', {
                method: 'GET', // *GET, POST, PUT, DELETE, etc.
                mode: 'cors', // no-cors, *cors, same-origin
                ...fetchOptions,
                credentials: 'same-origin', // include, *same-origin, omit
                headers: {
                    'Content-Type': 'application/json',
                    'X-Knack-Application-Id': knack_id, // change to your app's API info
                    'X-Knack-REST-API-Key': knack_key
                },
            })
                .then(i => i.json())
                .then(i => {
                    keys = i.fields
                })

            await fetch('https://api.knack.com/v1/objects/' + objectId + '/records?rows_per_page=1000', {
                method: 'GET', // *GET, POST, PUT, DELETE, etc.
                mode: 'cors', // no-cors, *cors, same-origin
                ...fetchOptions,
                credentials: 'same-origin', // include, *same-origin, omit
                headers: {
                    'Content-Type': 'application/json',
                    'X-Knack-Application-Id': knack_id, // change to your app's API info
                    'X-Knack-REST-API-Key': knack_key
                },
            })
                .then(i => i.json())
                .then(data => {
                    res = data.records.map(i => {
                        const temp = {};
                        Object.keys(i).map(s => {
                            const name = keys.find(k => k.key === s);
                            if (name) {
                                temp[name.label] = i[s]
                            }
                        });
                        return temp;
                    })
                })

            loadingDone(objectId);
            return res
        }

        const loaded = [];
        function loadingDone(param) {
            loaded.push(param)
            if (loaded.length === 4) {
                console.log('ALLDONE!');
                fetch('https://api.intuiface.com/webtriggers/v1/sendMessage?message=maploaded&playerTags=kingscentralmap&apikey=b58eded3-1d8b-40f3-8908-9d93335832bc');
            }
        }

        function getUrlParams() {

            const url = new URL(window.location);
            const lat = +url.searchParams.get('lat');
            const lng = +url.searchParams.get('lng');

            const debugMode = url.searchParams.get('debug');
            const amenityList = url.searchParams.get('amenitylist');
            const amenityid = +url.searchParams.get('amenityid');
            const lotid = +url.searchParams.get('lotid');
            const releaseid = +url.searchParams.get('releaseid');
            const lotactive = url.searchParams.get('lotactive');

            let zoom = +url.searchParams.get('zoom');

            urlProps.lat = lat
            urlProps.lng = lng
            urlProps.amenityid = amenityid
            urlProps.lotid = lotid
            urlProps.releaseid = releaseid
            urlProps.zoom = zoom
            urlProps.amenityList = amenityList
            urlProps.debugMode = debugMode
            urlProps.lotactive = lotactive


            if (!zoom) zoom = map.getZoom();

            if (lat && lng) {
                map.flyTo({
                    center: [lng, lat],
                    zoom
                })
            } else {
                map.flyTo({
                    center: map.getCenter(),
                    zoom
                })
            }

            if (debugMode) {
                infoDiv.style.display = 'inline'
            }

        }


        //LISTEN TO URL UPDATES
        history.pushState = (f => function pushState() {
            var ret = f.apply(this, arguments);
            window.dispatchEvent(new Event('pushstate'));
            window.dispatchEvent(new Event('locationchange'));
            return ret;
        })(history.pushState);

        history.replaceState = (f => function replaceState() {
            var ret = f.apply(this, arguments);
            window.dispatchEvent(new Event('replacestate'));
            window.dispatchEvent(new Event('locationchange'));
            return ret;
        })(history.replaceState);

        window.addEventListener('popstate', () => {
            window.dispatchEvent(new Event('locationchange'))
        });

        window.addEventListener('locationchange', function () {
            console.log('location changed!');
        })

        //*/


        /**
        * @param slider HtmlElement with an initialized slider
        * @param threshold Minimum proximity (in percentages) to merge tooltips
        * @param separator String joining tooltips
        */
        function mergeTooltips(slider, threshold, separator) {

            const moneyFormat = wNumb({ decimals: 0, thousand: ",", prefix: '$' })

            var textIsRtl = getComputedStyle(slider).direction === 'rtl';
            var isRtl = slider.noUiSlider.options.direction === 'rtl';
            var isVertical = slider.noUiSlider.options.orientation === 'vertical';
            var tooltips = slider.noUiSlider.getTooltips();
            var origins = slider.noUiSlider.getOrigins();

            // Move tooltips into the origin element. The default stylesheet handles this.
            tooltips.forEach(function (tooltip, index) {
                if (tooltip) {
                    origins[index].appendChild(tooltip);
                }
            });

            slider.noUiSlider.on('update', function (values, handle, unencoded, tap, positions) {

                var pools = [[]];
                var poolPositions = [[]];
                var poolValues = [[]];
                var atPool = 0;

                // Assign the first tooltip to the first pool, if the tooltip is configured
                if (tooltips[0]) {
                    pools[0][0] = 0;
                    poolPositions[0][0] = positions[0];
                    poolValues[0][0] = values[0];
                }

                for (var i = 1; i < positions.length; i++) {
                    if (!tooltips[i] || (positions[i] - positions[i - 1]) > threshold) {
                        atPool++;
                        pools[atPool] = [];
                        poolValues[atPool] = [];
                        poolPositions[atPool] = [];
                    }

                    if (tooltips[i]) {

                        pools[atPool].push(i);
                        poolValues[atPool].push(values[i]);
                        poolPositions[atPool].push(positions[i]);
                    }
                }

                pools.forEach(function (pool, poolIndex) {
                    var handlesInPool = pool.length;

                    for (var j = 0; j < handlesInPool; j++) {
                        var handleNumber = pool[j];

                        if (j === handlesInPool - 1) {
                            var offset = 0;

                            poolPositions[poolIndex].forEach(function (value) {
                                offset += 1000 - 10 * value;
                            });

                            var direction = isVertical ? 'bottom' : 'right';
                            var last = isRtl ? 0 : handlesInPool - 1;
                            var lastOffset = 1000 - 10 * poolPositions[poolIndex][last];
                            offset = (textIsRtl && !isVertical ? 100 : 0) + (offset / handlesInPool) - lastOffset;

                            console.log('JSON.stringify(poolValues)', JSON.stringify(poolValues[poolIndex][0]));

                            const formated = poolValues[poolIndex].map(i => {
                                return moneyFormat.to(+i)
                            })

                            // Center this tooltip over the affected handles
                            // tooltips[handleNumber].innerHTML = poolValues[poolIndex].join(separator);
                            tooltips[handleNumber].innerHTML = formated.join(separator);
                            tooltips[handleNumber].style.display = 'block';
                            tooltips[handleNumber].style[direction] = offset + '%';
                        } else {
                            // Hide this tooltip
                            tooltips[handleNumber].style.display = 'none';
                        }
                    }
                });
            });
        }
    </script>

</body>

</html>